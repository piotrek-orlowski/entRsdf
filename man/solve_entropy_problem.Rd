% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/entropy_solver.R
\name{solve_entropy_problem}
\alias{solve_entropy_problem}
\title{Generic solver for minimum-entropy pricing kernels}
\usage{
solve_entropy_problem(
  entropy_foos,
  excess_return_matrix,
  theta_vector_init = rep(1, ncol(excess_returns))/ncol(excess_returns),
  solver_trace = FALSE,
  ...
)
}
\arguments{
\item{entropy_foos}{object of \code{entropy_functions} S4 class}

\item{excess_return_matrix}{T x N \code{matrix} of excess returns}

\item{theta_vector_init}{(N+1) x 1 \code{numeric} or \cide{matrix} of initial weights}

\item{solver_trace}{sets the \code{trace} argument in \code{cccp::ctrl} call which is passed to \code{cccp::cccp}}

\item{...}{arguments passed to \link{\code{cccp::ctrl}}}
}
\value{
(N+1) x 1 \code{matrix}
}
\description{
Given an objective function, its gradient and hessian (in the \code{entropy_foos} object), this function submits them to a convex solver and returns the vector of optimal portfolio weights plus a normalization weight in the first position. This function is supposed to be used internally in the implementation of generic methods for SDF fitting.
}
\details{
For N assets, the vector of portfolio weights is of length N+1, because in the first position it contains the Lagrange multiplier for the constraint that the average of the pricing kernel time series is equal to 1.0. Thus, the portfolio weights are in fact in positions \code{2:(N+1)}.
}
